\chapter{README}
\hypertarget{md__c_1_2_darbai_22___o_p_2_r_e_a_d_m_e}{}\label{md__c_1_2_darbai_22___o_p_2_r_e_a_d_m_e}\index{README@{README}}
// 1 DALIS // APRAŠ\+YMAS\+:

Su šia programa yra testuojama programos sparta, naudojant skirtingus konteinerius (std\+::vector, std\+::list, std\+::deque). Matuojama\+: duomenų nuskaitymas iš failo į atitinkamą konteinerį studentų rūšiavimas didėjimo tvarką konteineryje studentų skirstymas į dvi grupes/kategorijas

REZULTATAI\+: 1000

 

10 000

 

100 000

 

1 000 000

 

10 000 000

 

APIBENDRINIMAS\+:



Atlikti visus šiuos veiksmus greičiausiai pavyko naudojant std\+::list, o daugiausia buvo sugaišta laiko su std\+::deque konteineriu. Nuskaitymas trumpiausiai užtruko su std\+::deque, rūšiavimas žymiai trumpiau su std\+::list, o mokinių suskirstymas -\/ std\+::vector. // 2 DALIS // APRAŠ\+YMAS\+:

Optimizuojama studentų rūšiavimo į 2 kategorijas ("{}\+Vargšiukai"{}; "{}\+Kietiakai"{}) realizacija. Visiems trims konteinerių tipams (vector, list ir deque) išmatuojame programos veikimo spartą priklausomai nuo studentų dalijimo strategijos.

REZULTATAI\+: 1 strategija Bendro studentai konteinerio (vector, list ir deque tipų) skaidymas (rūšiavimas) į du naujus to paties tipo konteinerius\+: "{}vargšiukų"{} ir "{}kietiakų"{}.











2 strategija Bendro studentų konteinerio (vector, list ir deque) skaidymas (rūšiavimas) panaudojant tik vieną naują konteinerį\+: "{}vargšiukai"{}.











3 strategija Bendro studentų konteinerio (vector, list ir deque) skaidymas (rūšiavimas) panaudojant greičiausiai veikianti 1 arba 2 strategiją įtraukiant į ją "{}efektyvius"{} darbo su konteineriais metodus (std\+::copy, std\+::remove, std\+::remove\+\_\+if, std\+::partition)











APIBENDRINIMAS\+:



GREIČ\+IAUSIAI ATLIKTA\+:

VECTOR NUSKAITYMAS -\/ 1 strategija VECTOR RŪŠ\+IAVIMAS -\/ 1 strategija VECTOR SUSKIRSTYMAS -\/ 3 strategija

LIST NUSKAITYMAS -\/ 1 strategija LIST RŪŠ\+IAVIMAS -\/ 1 strategija LIST SUSKIRSTYMAS -\/ 1 strategija

DEQUE NUSKAITYMAS -\/ 1 strategija DEQUE RŪŠ\+IAVIMAS -\/ 1 strategija DEQUE SUSKIRSTYMAS -\/ 1 strategija

Taigi galima teigti, jog šioje programoje laiko atžvilgiu naudingiausia naudoti 1 strategiją (bet svarbu paminėti, kad ši strategija nėra efektyvi užimamos atminties atžvilgiu), 2-\/oji strategija garantuoja atminties efektyvumą, teoriškai mąstant turėjo sutaupyti laiko, palyginant rūšiavime ir nuskaityme tam tikrose vietose (iki 1000 000 failo) sugaištas laikas tikrai yra mažesnis, bet pasiekus 10 000 000 failą, efektyvumas ženkliai sumažėjo, todėl ir bendri rezultatai yra šiek tiek blogesni už 1-\/ąją strategiją, o 3-\/oje strategijoje naudojami algoritmai leidžia supaprastinti kodą, nors mano atveju rezultatai yra panašūs į 2-\/osios strategijos rezultatus, galbūt, kad dalis algoritmų jau buvo naudojami 2-\/oje strategijoje. Atsižvelgiant į konteinerius, iš 1-\/ojo testo išsiaiškinome, jog std\+::list nuskaityme ir suskirstyme yra pranašiausias, todėl yra pravartu pasirinkti jį.

PROGRAMOS NAUDOJIMOSI INSTRUKCIJA\+:
\begin{DoxyEnumerate}
\item Prisijungiame prie Github paskyros, jei jos neturime, susikuriame ir susikonfiguruojam Github. \href{https://docs.github.com/en/get-started/getting-started-with-git/set-up-git}{\texttt{ https\+://docs.\+github.\+com/en/get-\/started/getting-\/started-\/with-\/git/set-\/up-\/git}}
\item Tuomet, parsisiunčiam Visual Studio Code (galima naudoti ir kitą aplinką, bet instrukciją tęsiu su VS Code) \href{https://code.visualstudio.com/download}{\texttt{ https\+://code.\+visualstudio.\+com/download}}
\item Parsisiunčiame paketus. Atsidarius VS Code kairėje, 5 mygtukas vertikaliai, jį paspaudus randame visus paketus. ("{}\+CMake"{}; "{}\+CMake Tools"{}; "{}\+C/\+C++ Themes"{}; "{}\+C/\+C++ Runner"{}; "{}\+C/\+C++ Extension Pack"{}; "{}\+C/\+C++"{})
\item Parsisiunčiam šį kodą, įsidedame į norimą folderį pvz\+:(C\+:\textbackslash{}\+Darbai\textbackslash{}1\+\_\+\+OP) ir atidarome jį Visual Studio Code aplinkoje. \href{https://github.com/Jovitel/1_OP/tree/v1.0_1}{\texttt{ https\+://github.\+com/\+Jovitel/1\+\_\+\+OP/tree/v1.\+0\+\_\+1}}
\item Terminale (jeigu jo nėra, viršuje paspaudžiame ant 3 taškiukų ir paspaudžiame "{}\+New terminal"{}) paspaudžiame kairėje prie "{}+"{} esančia rodyklę, rodančią į apačią. Pasirenkame "{}\+Command Prompt"{}.
\item Naudojant cd pasiekiame vietą, kur yra kodas. PVZ\+: cd C\+:\textbackslash{}\+Darbai\textbackslash{}1\+\_\+\+OP
\item Norint paleisti kodą, terminale, Command Prompt, įrašome "{}vektoriai"{}
\item Terminale pamatysit 6 pasirinkimus, jų pavadinimai nusako, kokie veiksmai bus atlikti, įvykdžius tam tikrą pasirinkimą.
\end{DoxyEnumerate}

Štai smulkesni pasirinkimų aprašymai\+: 1. Programos pradžia. Įvedama\+:

Kelių mokinių pažymiai bus apskaičiuojami Kiek bus įrašoma namų darbų pažymių Taip pat įvedami egzamino rezultatai Išvedama Pavardė, vardas Galutinis balas arba mediana (pasirenkama) Neledžiama vartotojui įvesti nelogiškus atsakymus, tai padarius programa informuoja vartotoją (PVZ ten, kur skirta įvesti pažymius nuo 1 iki 10 nebus leidžiama įvesti didesnių skaičių arba raidžių)

2. Galima pasirinkti, ar nori, kad pažymiai ir vardai būtų sugeneruojami atsitiktinai (tai buvo įgyvendinta 2 atskiruose failuose, tik su vektoriais ir tik su masyvais) Yra meniu skirtingos programos eigos pasirinkimui (1 -\/ ranką, 2 -\/ generuoti pažymius, 3 -\/ generuoti ir pažymius ir studentų vardus, pavardės, 4 -\/ baigti darbą).

3. Galima pasirinkti, ar nori, kad pažymiai ir vardai būtų sugeneruojami atsitiktinai (tai buvo įgyvendinta 2 atskiruose failuose, tik su vektoriais ir tik su DINAMINIAIS masyvais) Yra meniu skirtingos programos eigos pasirinkimui (1 -\/ ranką, 2 -\/ generuoti pažymius, 3 -\/ generuoti ir pažymius ir studentų vardus, pavardės, 4 -\/ baigti darbą).

4. Užbaigti programą. 5. Duomenys nuskaitomi iš failo, apskaičiuojama, per kiek laiko nuskaitoma.

6. Generuojami failai su mokiniais ir jų pažymiais iš anksto. Reikia pasirinkti, kiek mokinių generuoti bei jų pažymių skaičių. Mokiniai yra suskirstomi pagal galutinius vidurkius (\texorpdfstring{$<$}{<}5 vargšiukai; \texorpdfstring{$>$}{>}=5 kietiakai) ir padalinami į 2 atskirus failus. Yra 3 strategijos bei 3 skirtingi konteineriai, std\+::vector; std\+::list; std\+::deque 